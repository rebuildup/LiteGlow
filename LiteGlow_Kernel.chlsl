cbuffer LiteGlowGPUParams : register(b0)
{
    int   srcPitch;
    int   dstPitch;
    int   width;
    int   height;
    float strengthNorm;
    float threshold;
    float radius;
    int   quality;
};

RWByteAddressBuffer gDst : register(u0);
ByteAddressBuffer  gSrc : register(t0);

static const float3 kLumaWeights = float3(0.2126f, 0.7152f, 0.0722f);

uint4 LoadPixel(uint x, uint y)
{
    const uint bytesPerPixel = 16;
    uint index = (y * (uint)srcPitch + x) * bytesPerPixel;
    return gSrc.Load4(index);
}

void StorePixel(uint x, uint y, float4 value)
{
    const uint bytesPerPixel = 16;
    uint index = (y * (uint)dstPitch + x) * bytesPerPixel;
    gDst.Store4(index, asuint(value));
}

float Gaussian1D(float dist, float sigma)
{
    return exp(-dist * dist / (2.0f * sigma * sigma));
}

[numthreads(16,16,1)]
void main(uint3 dtid : SV_DispatchThreadID)
{
    uint x = dtid.x;
    uint y = dtid.y;
    if (x >= (uint)width || y >= (uint)height)
        return;

    uint4 baseRaw = LoadPixel(x, y);
    float4 basePixel = asfloat(baseRaw);

    float baseLuma = dot(basePixel.rgb, kLumaWeights);
    float mask = saturate((baseLuma - threshold) * 4.0f);

    if (mask <= 0.0f || strengthNorm <= 0.01f)
    {
        StorePixel(x, y, basePixel);
        return;
    }

    // 品質に応じてサンプル数を調整
    int samplesPerDir = quality == 3 ? 8 : (quality == 2 ? 6 : 4);
    float rad = max(radius, 1.0f);
    float sigma = rad * 0.4f;  // より広い分布のために調整

    // より多くの方向をサンプリング（16方向で滑らかなグロー）
    static const float2 dirs[16] = {
        float2(1.0f, 0.0f),      float2(-1.0f, 0.0f),
        float2(0.0f, 1.0f),      float2(0.0f, -1.0f),
        float2(0.7071f, 0.7071f),   float2(-0.7071f, 0.7071f),
        float2(0.7071f, -0.7071f),  float2(-0.7071f, -0.7071f),
        float2(0.9239f, 0.3827f),   float2(-0.9239f, 0.3827f),
        float2(0.3827f, 0.9239f),   float2(-0.3827f, 0.9239f),
        float2(0.9239f, -0.3827f),  float2(-0.9239f, -0.3827f),
        float2(0.3827f, -0.9239f),  float2(-0.3827f, -0.9239f)
    };

    float3 accum = basePixel.rgb * mask;
    float totalW = mask;

    int numDirections = quality >= 2 ? 16 : 8;

    // 方向ごとにサンプリング
    for (int d = 0; d < numDirections; ++d)
    {
        float2 dir = dirs[d];

        // 距離ごとにサンプリング
        for (int s = 1; s <= samplesPerDir; ++s)
        {
            float t = (float)s / (float)samplesPerDir;
            float dist = rad * t;
            float w = Gaussian1D(dist, sigma);

            int sx = (int)(x + dir.x * dist + 0.5f);
            int sy = (int)(y + dir.y * dist + 0.5f);

            // 境界チェック
            if (sx >= 0 && sx < width && sy >= 0 && sy < height)
            {
                float4 sample = asfloat(LoadPixel((uint)sx, (uint)sy));
                float lum = dot(sample.rgb, kLumaWeights);

                // 閾値を超える明るいピクセルのみを考慮
                if (lum > threshold)
                {
                    float sampleMask = saturate((lum - threshold) * 4.0f);
                    accum += sample.rgb * w * sampleMask;
                    totalW += w * sampleMask;
                }
            }
        }
    }

    // グローの計算
    float3 glow = totalW > 0.0f ? (accum / totalW) : basePixel.rgb;
    
    // 強度を適用（より強力なグロー効果）
    float glowStrength = saturate(strengthNorm * 2.0f);
    glow *= (1.0f + glowStrength * 2.0f);
    
    // スクリーンブレンドで元の画像と合成
    float3 screenColor = 1.0f - (1.0f - basePixel.rgb) * (1.0f - saturate(glow));
    
    // さらに加算ブレンドを追加して強いグローを実現
    float3 additiveGlow = glow * glowStrength * 0.5f;
    float3 finalColor = saturate(screenColor + additiveGlow);

    StorePixel(x, y, float4(finalColor, basePixel.a));
}
